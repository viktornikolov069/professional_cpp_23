# NOTES

*Things I learned while reading Professional C++23, 6th Edition.*

## Table of Contents

- [Part 1](#part-1)
- [Part 2 / Working with Strings and String Views](#part-2--working-with-strings-and-string-views)
- [Part 3 / Coding with Style](#part-3--coding-with-style)
- [Appendices](#appendices)
  - [Designated Initializers](#designated-initializers)
  - [Uniform Initialization](#uniform-initialization)
  - [References](#references)

### Part 1

1. The function name combined with the parameter list but excluding the return type is called the **function signature**.

2. Placing `auto` in front of a function is called **function return type deduction**. The compiler deduces the return type based on the expression used in the return statement.

3. Every function has a local predefined variable called `__func__` which can be used for logging purposes.

4. **Overload resolution**: based on the provided arguments the compiler automatically selects which overloaded function to call.

5. Attributes are a feature in C++ that allow the programmer to hint the compiler about her intentions. For example to suppress or issue some warnings generated by the compiler and other things.

6. **CTAD**: Class template automatic deduction (CTAD). Supported by most containers when using an initializer.

7. Don't return an `std::pair` from a function directly because the client of that function needs to use **first** and **second** which is bad naming. Better create a struct or small class to return the two values with better naming.

8. **Structured bindings**: Allows you to declare multiple variables that are initialized with elements from a data structure such as an *array*, *struct*, *pair*. A use case is to decompose the values of a container.

   ```c++
   std::pair my_pair {"hello", 5};
   auto [the_string, the_int] {my_pair}; // Decompose using structured bindings.
   ```

9. **In-class initializers**: Data members in a class can be initialized directly within the class without the need of a Constructor.

10. *Undefined symbol error*: Generated by the compiler when a variable isn't found in a certain scope and finally in the global scope.

11. **Uniform Initialization**: [See Appendix](#uniform-initialization)

12. **Designated Initializers**: [See Appendix](#designated-initializers)

13. **Anonymous / unnamed namespaces**: A namespace without a name which can clash with the global namespace. For example if two identical functions are defined in the global namespace and in the anonymous one the result will be a compilation error.

14. Allocating dynamic memory in C++ is done on the **Free Store**.

15. **Short-circuit** is a powerful concept which can be used for writing safer code.

    ```c++
    bool isValidSalary { anEmployee != nullptr &&    anEmployee->salary> 0 };
    // checks if anEmployee is a null-pointer first and  then dereferences
    ```

16. **Const Pointers:** A trick to figure out complicated variable declarations including `const` is to read the declaration from **right-to-left**.
    - `int* const ip` - *ip is a constant pointer to an int value*
    - `int const* ip` - *ip is a pointer to a const int*
    - `const int* ip` - *ip is a pointer to an int constant*

17. **Const correctness**: Member functions which do not modify data members must be marked with const.
    - Functions which are `const` are called **inspectors**
    - Functions which are `non-const` are called **mutators**

18. **References**: [See Appendix](#references)
19. **TIP:** The recommended way to return objects from a function is to return them by value, instead of using output parameters.
    - Another option to return an object from a function without creating a copy is to pass it as an output parameter. The compiler however is smart enough to optimize the code so no copy is created if the function simply returns that object therefore the above tip is the recommended way to return objects from functions.

20. `auto` strips away reference and const qualifiers and thus creates a **copy**! If you do not want a copy use `auto&` ot `const auto&`.
21. Default values added to function arguments are allowed only in the function declaration not the function definition.

    ```c++
    //Declaration
    class Employee {
      void promote(int raiseAmount =     DefaultRaiseAndDemeritAmount);
    }
    
    //Definition
    void Employee::promote(int raiseAmount) {
      setSalary(getSalary() + raiseAmount);
    }
    ```

### Part 2 / Working with Strings and String Views

1. The most common mistake in classic **C** programming is forgetting to allocate space for the `\0` character. For example `hello` takes 6 characters worth of memory not 5.
   - The `\0` character is called `NUL` with a single **L**.
2. Copying string in **C**
   - The **incorrect** way vs the **correct** way.
     - `strlen` returns the actual length of the string not the memory needed to hold it. In this case if we pass **hello** as input `strlen` will return 5 instead of 6.
     - We need to add `+1` after strlen to compensate for the output of `strlen`

   ```c++
   char* copyString(const char* str) {
       char* result { new char[strlen(str)] }; // BUG! Off by one!
       //
       strcpy(result, str);
       return result;
   }
   ```

   ```c++
   char* copyString(const char* str) {
       char* result { new char[strlen(str) + 1] };
       strcpy(result, str);
       return result;
   }
   ```

3. **Literal pooling**
   - String literals are stored in a read-only part of memory which allows the compiler to reuse references to equivalent string literals.
   - `char arr[] { "hello" };` - In this case however the compiler does not store **hello** in read-only memory and does not do literal pooling.
4. Writing to read-only memory (pointing to a string literal and trying to change it) is often allowed in C++ but it results in **undefined behavior**.
   - Using a pointer to const is a safer way of assigning a literal to a variable.
     - The compiler will stop you with an error if you try to modify it.
5. `string.contains()` C++23 introduces the string method `contains()` which checks if a string is present in another string. (I'm so happy someone finally decided to add this :D)
   - Returns `true` or `false`
6. **Inline namespace** - everything declared in a inline namespace is automatically available in the parent namespace.
7. `std::string_view` given as a parameter type to a function accepting a read only string.
   - Should be used instead of `const std::string&` and `const char*` for read-only strings.
   - Contains only a pointer to, and the length of the string.
      - **Note!** Be careful when using **string_view**! Be clear about your use case!
      - **Note!** The fact that a **string_view** only stores a pointer and a length means that bugs can be introduced. For example. Never use a **string_view** for storing a temporary value as you will be left with a dangling pointer.
   - Very efficient as no copies are made when passing values.
   - Works fine when passing `std::string`, `const char*` or a *string literal* as parameters.
8. The way in which strings are represented across development frameworks and operating systems differs therefore it is necessary to choose the way in which string will be represented before the beginning of a project.
   - Strings can be standardized depending on the framework (Qt, MFC...)
   - A group can decide to stick with **std::string**

### Part 3 / Coding with Style

1. **Invariant**: A condition that must be true during the execution of a piece of code.

2. **Note!** Unit tests are essential for catching defects when refactoring code.

3. **Tip!** The Standard Library includes a collection of predefined mathematical constants defined in `<numbers>` in the `std::numbers` namespace.
   - Examples are `std::numbers::e, pi, sqrt2, phi`

## Appendices

### Designated Initializers

1. Introduced in C++20, designated initializers allow you to initialize specific members of an aggregate type by name.
   - Aggregate types are:
     - Object of an array type.
     - Object of a structure or class that satisfies the following restrictions:
       - Only public data members
       - No user declared or inherited constructors
       - No virtual functions
       - No virtual, private or protected base classes
2. Mixing designated initializers and non-designated initializers is not allowed.
3. Designated initializers must be in the same order as the declaration order of the data members

   ```c++
   struct Point {
       int x {10};
       int y;
       int z;
   };
   
   Point p = {.y = 11, .z = 12}; // z is default-initialized    to 0
   ```

### Uniform Initialization

1. Performs zero-initialization by default.
2. Removes different types of initializations achieving uniformity.
3. Prevents narrowing
   - `int x {3.14};` results in a compilation error instead of truncating the value to `3`.
4. Can be used in constructor initializers and with containers.

### References

*An alias for another variable.*

1. Initialized as soon as they are created.
2. Const in therms that we cannot change what it refers to.
   - We only change the referred value.
3. References can be made to literals and temporary values only if they are `const`.

   ```c++
   int& unnamedRef1 { 5 };// DOES NOT COMPILE
   const int& unnamedRef2 { 5 }; // Works as expected
   ```

4. In the case of a function returning a temporary object. Creating a const reference to that object will keep it alive until the reference goes out of scope.

   ```c++
   string getString() { 
       return "Hello world!"; 
   }
   
   string& string1 { getString() };// DOES NOT COMPILE
   const string& string2 { getString() }; // Works as expected
   ```

5. We cannot declare a reference to a reference or a pointer to a reference. `int& &` and `int&*` are not allowed.
6. A class data member can also be declared as a reference but it must be initialized through a constructor initializer list.
